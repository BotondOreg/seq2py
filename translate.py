# transcribe digital blocks and analog constant setpoints from a Cicero .seq to a labscript

from main import yaml_to_list, compare_words
import pandas as pd


def print_analog_group(word):
    """
    Return a dictionary for code generation from a Cicero sequence word.
    """

    def print_value_dict(value, preamble=None):
        """
        Pretty print list of dictionaries. Returns True if parameter comes from a variable/formula.
        """
        print(preamble, value['ParameterString'])
        if value['parameter']['variable'] is not None:
            print('This parameter derives from a formula!')
            return True
        return False

    analog_constant_tuples = []
    derived_analog_channels = []
    analog_waveform_tuples = []
    print('analog group name: ', word['AnalogGroup']['GroupName'])
    for analog_output_idx, analog_output in word['AnalogGroup']['ChannelDatas'].items():
        if not analog_output['ChannelEnabled']:
            continue
        print('analog output logical index: ', analog_output_idx)
        if len(analog_output['waveform']['XValues']) == 1:
            if (analog_output['waveform']['XValues'][0]['ParameterString'] != '0 s' and
                    analog_output['waveform']['XValues'][0]['ParameterString'] != '-0 s'):
                raise ValueError(
                    'Check if this is actually an analog constant setpoint.')
            derived_bool = print_value_dict(
                analog_output['waveform']['YValues'][0], preamble='constant analog output, yValue: ')
            analog_constant_tuples.append(
                (analog_output_idx, analog_output['waveform']['YValues'][0]['ParameterString']))

        elif len(analog_output['waveform']['XValues']) > 1:
            print('Ramp or other waveform outputting on this channel.')
            derived_bool = False
            my_list = []
            for x_dict, y_dict in zip(analog_output['waveform']['XValues'], analog_output['waveform']['YValues']):
                derived_bool = derived_bool or print_value_dict(
                    x_dict, preamble='xValue: ')
                derived_bool = derived_bool or print_value_dict(
                    y_dict, preamble='yValue: ')
                my_list.append(
                    (x_dict['ParameterString'], y_dict['ParameterString']))

            analog_waveform_tuples.append((analog_output_idx, tuple(my_list)))

        if len(analog_output['waveform']['XValues']) != 0 and derived_bool:
            derived_analog_channels.append(analog_output_idx)

        print('\n')

    return {'analog_constant_tuples': analog_constant_tuples,
            'derived_analog_channels': derived_analog_channels,
            'analog_waveform_tuples': analog_waveform_tuples
            }


def generate_analog_code(analog_dict, chl_names):
    with open('autogenerated.py', 'a') as f:
        f.write('#analog outputs\n')
        for (idx, value) in analog_dict['analog_constant_tuples']:
            if idx in chl_names:
                name = chl_names[idx]
                value = value.replace(' V', '')
                f.write(f'{name}.constant(t=t, value={value})\n')
        for chl in analog_dict['derived_analog_channels']:
            if chl in chl_names:
                name = chl_names[chl]
                f.write(
                    f'raise ValueError(\'Analog channel {name} is derived from a formula.\')\n')
        for (chl, my_tuple) in analog_dict['analog_waveform_tuples']:
            if chl in chl_names:
                name = chl_names[chl]
                f.write(
                    f'raise ValueError(\'Analog channel {name} has a waveform.\')\n')
                f.write('#' + str(my_tuple) + '\n')


def print_digital_data(word, prev_word=None):
    """
    Return a dictionary for code generation from a Cicero sequence word.
    """
    if prev_word is None:  # first word
        high_channels, low_channels, pulsed_channels = [], [], []
        for logical_idx, data in word['DigitalData'].items():
            if data['ManualValue']:
                print(f'digital output idx {logical_idx} going high.')
                high_channels.append(logical_idx)
            else:
                print(f'digital output idx {logical_idx} going low.')
                low_channels.append(logical_idx)
            if data['DigitalPulse'] is not None:
                pulsed_channels.append(logical_idx)
                print('Pulse {name} associated with channel {idx}.'.format(
                    name=data['DigitalPulse']['PulseName'], idx=logical_idx))
    else:
        high_channels, low_channels, pulsed_channels = [], [], []
        logical_idxs = set.intersection(
            set(prev_word['DigitalData'].keys()), set(word['DigitalData'].keys()))
        for logical_idx in logical_idxs:
            prev_data, data = prev_word['DigitalData'][logical_idx], word['DigitalData'][logical_idx]
            if prev_data['ManualValue'] != data['ManualValue']:
                if not prev_data['ManualValue']:
                    if logical_idx == 41:
                        breakpoint()
                    print(f'digital output idx {logical_idx} going high.')
                    high_channels.append(logical_idx)
                else:
                    print(f'digital output idx {logical_idx} going low.')
                    low_channels.append(logical_idx)
            if data['DigitalPulse'] is not None:
                pulsed_channels.append(logical_idx)
                print('Pulse {name} associated with channel {idx}.'.format(
                    name=data['DigitalPulse']['PulseName'], idx=logical_idx))

    return {
        'high_channels': high_channels,
        'low_channels': low_channels,
        'pulsed_channels': pulsed_channels
    }


def generate_digital_code(digital_dict, chl_names):
    with open('autogenerated.py', 'a') as f:
        f.write('#digital outputs\n')
        for idx, name in chl_names.items():
            if idx in digital_dict['high_channels']:
                f.write(f'{name}.go_high(t=t)\n')
            if idx in digital_dict['low_channels']:
                f.write(f'{name}.go_low(t=t)\n')
            if idx in digital_dict['pulsed_channels']:
                f.write(f'raise ValueError(\'Channel {name} has a pulse.\')\n')


filename = 'p5sMagtrap2022-08-24.yaml'
my_list = yaml_to_list(filename)
df_analog = pd.read_csv(
    r'C:\Users\alexc\labscript-suite\userlib\labscriptlib\fermi1_apparatus\ciceroSettings\NI_analog_chls.csv')
df_digital = pd.read_csv(
    r'C:\Users\alexc\labscript-suite\userlib\labscriptlib\fermi1_apparatus\ciceroSettings\NI_digital_chls.csv')
df_analog.sort_values(by='category', inplace=True)
df_digital.sort_values(by='category', inplace=True)
analog_chl_names = {idx: name for idx, name in zip(
    df_analog.logical_id, df_analog.labscriptChlName)}
digital_chl_names = {idx: name for idx, name in zip(
    df_digital.logical_id, df_digital.labscriptChlName)}

for i in range(len(digital_chl_names)):
    if i not in digital_chl_names:
        print(i)

with open('autogenerated.py', 'w') as f:
    f.write(f'#autogenerated from {filename}\n')
    f.write('start()\n')
    f.write('t=0\n')

for word_idx, word in enumerate(my_list):
    if not word['StepEnabled']:
        raise ValueError(
            'Support for transcribing sequences with disabled steps is currently not available.')
    print('\n')
    with open('autogenerated.py', 'a') as f:
        f.write(
            '###############################################################################################\n')
        f.write('#' + word['StepName'] + '\n')

    if word_idx == 0:
        parsed_digital_dict = print_digital_data(word, prev_word=None)
    else:
        parsed_digital_dict = print_digital_data(
            word, prev_word=my_list[word_idx-1])
    # breakpoint()
    generate_digital_code(parsed_digital_dict, chl_names=digital_chl_names)
    if word['AnalogGroup'] is not None:
        parsed_analog_dict = print_analog_group(word)
        generate_analog_code(parsed_analog_dict, chl_names=analog_chl_names)
    with open('autogenerated.py', 'a') as f:
        f.write('t+={dt}\n'.format(dt=word['StepDuration']['ParameterValue']))
with open('autogenerated.py', 'a') as f:
    f.write('stop(t=t)')
